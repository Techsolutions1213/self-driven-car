from rplidar import RPLidar
from math import floor
import numpy as np
import serial
import glob
import time

class lidar(object):
    def __init__(self, maxDist=1500) -> None:

        # Find the serial port where the lidar is connected
        port_found = False
        temp_list = glob.glob('/dev/ttyUSB*')
        result = []
        for port in temp_list:
            try:
                s = serial.Serial(port)
                s.close()
                result.append(port)
                port_found = True
            except serial.SerialException:
                pass
        if not port_found:
            raise RuntimeError("No RPLidar is connected.")

        self.port = result[0]
        self.lidar = RPLidar(self.port, timeout=3)
        self.lidar.clear_input()
        time.sleep(1)

        self.running = True
        self.dist_data = np.zeros(210, dtype='int16')
        self.max_dist = maxDist # Default max distance


    def poll(self):
        self.measurements = self.lidar.iter_scans()
        try:
            new_scan, quality, angle, distance = next(self.iter_measurements)

            # Resetting the distance values
            if new_scan:
                self.dist_data = np.zeros(210, dtype='int16')

            # Floor the angle, set the limit to 359 then converting it to pi radians
            angle = min([359, floor(angle)]) 

            if angle < 75 or angle >= 285: # Filtering out the unnecessary angles 
                return

            if distance > self.max_dist: # Filtering out the unnecessary distances
                return

            self.dist_data[angle - 75] = floor(distance)

        except:
            pass


    def update(self):
        start_time = time.time()
        while(self.running):
            self.poll()
            time.sleep(0)
        print(time.time() - start_time)

    def shutdown(self):
        self.running = False
        time.sleep(2)
        if self.lidar is not None:
            self.lidar.stop()
            self.lidar.stop_motor()
            self.lidar.disconnect()
            self.lidar = None


# def range(self, ls, le, ms, me, rs, re, thresh=700, _range=32):

#         # Setting the default distance values
#         l_start = 800
#         l_end = 800

#         m_start = 800
#         m_end = 800

#         r_start = 800
#         r_end = 800

#         # Debugging the data generated by the RPLidar:
#         for i in range(_range):
#             _ls = ls + i
#             _me = me - i
#             _re = re - i

#             _le = le - i
#             _ms = ms + i
#             _rs = rs + i

#             # Left section
#             if(self.data[_ls] > 1):
#                 l_start = self.data[_ls]
#             if(self.data[_le] > 1):
#                 l_end = self.data[_le]

#             # Middle section
#             if(self.data[_ms] > 1):
#                 m_start = self.data[_ms]
#             if(self.data[_me] > 1):
#                 m_end = self.data[_me]

#             # Right section
#             if(self.data[_rs] > 1):
#                 r_start = self.data[_rs]
#             if(self.data[_re] > 1):
#                 r_end = self.data[_re]

#         # Debugging the distance values:
#         if((l_start < thresh ) or (l_end  < thresh)): #100
#             return 'l' # -0.035 
#         elif((r_start < thresh ) or (r_end  < thresh)): #001
#             return 'r' # 0.035
#         elif((m_start < thresh ) or (m_end  < thresh)): #010
#             return 'm' # -0.035
#         else:
#             return 'f' # -0.02
